Dinitz and Stinson choose to implement the above algorithm in Pascal, and ran in on an Amdahl 5850 workstation.
It was very successful, finding many Room squares with sides ranging from 11 to 101.
For each successful trial they had 9 or 10 failures (the program being stopped by the threshold function) and timings ranged from 0.09 seconds for an $11 \times 11$ Room square, to 7.3 on average for the 25 different $101 \times 101$ Room squares they found.

I chose to implement the hill-climbing algorithms in Visual Basic 6.0 on a Pentium III-450/Win 98 Desktop.
Needless to say, it was slightly less successful â€“ exhibiting a similar probability of success but unfortunately becoming very slow for Room squares bigger than 21.
It found one square of side 21 after an all-night search, but after 48 hours looking for one of $23 \times 23$ I decided to call the search off.

Despite the failures at higher order, the Room square generator was very successful in finding smaller squares.
It found $7 \times 7$ Room squares in as little as 4 seconds, and even $15 \times 15$ squares only took a few minutes.

Annotated code for the Room square generator can be found along with some of the larger squares in Appendix I and below is a screen shot of the application having successfully located a $9 \times 9$ Room square in a little over one minute after 507 iterations of the heuristics $OH_1$ and $OH_2$.
The uppermost panel represents some of the one-factorisation generated by the algorithm involving $H_1$ and $H_2$, while the second panel shows part of the orthogonal one-factorisation generated by $OH_1$ and $OH_2$.
The lower panel is a Room square of side 9.
